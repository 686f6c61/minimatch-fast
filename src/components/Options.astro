---
const coreOptions = [
  { name: 'dot', type: 'boolean', default: 'false', description: 'Match dotfiles (files starting with .). By default, * and ? do not match leading dots.' },
  { name: 'nocase', type: 'boolean', default: 'false', description: 'Perform case-insensitive matching.' },
  { name: 'nonegate', type: 'boolean', default: 'false', description: 'Suppress negation behavior with leading !.' },
  { name: 'nobrace', type: 'boolean', default: 'false', description: 'Do not expand brace patterns like {a,b,c}.' },
  { name: 'noext', type: 'boolean', default: 'false', description: 'Disable extglob patterns like ?(a|b), *(a|b), etc.' },
  { name: 'noglobstar', type: 'boolean', default: 'false', description: 'Disable ** matching across directory boundaries.' },
  { name: 'nocomment', type: 'boolean', default: 'false', description: 'Suppress treating # as a comment character.' },
  { name: 'matchBase', type: 'boolean', default: 'false', description: 'If pattern has no slashes, match basename of the path. foo matches bar/baz/foo.' },
  { name: 'partial', type: 'boolean', default: 'false', description: 'Partial match: pattern can match a portion of the path.' },
  { name: 'flipNegate', type: 'boolean', default: 'false', description: 'Returns true for negated patterns that do not match.' },
  { name: 'preserveMultipleSlashes', type: 'boolean', default: 'false', description: 'Do not collapse multiple slashes (a//b stays as a//b).' },
  { name: 'optimizationLevel', type: 'number', default: '1', description: 'Regex optimization level: 0 = none, 1 = safe (default), 2 = aggressive.' },
  { name: 'platform', type: 'string', default: 'process.platform', description: 'Platform for path handling: "win32", "darwin", "linux", etc.' },
  { name: 'windowsPathsNoEscape', type: 'boolean', default: 'false', description: 'On Windows, treat \\ as path separator, not escape character.' },
  { name: 'allowWindowsEscape', type: 'boolean', default: 'platform !== "win32"', description: 'Allow \\ as escape character on Windows.' },
  { name: 'nocaseMagicOnly', type: 'boolean', default: 'false', description: 'Only apply nocase to magic portions of the pattern.' },
  { name: 'magicalBraces', type: 'boolean', default: 'false', description: 'Treat brace expansion as magic (affects hasMagic()).' },
  { name: 'debug', type: 'boolean', default: 'false', description: 'Enable debug output.' },
];

const extendedOptions = [
  { name: 'ignore', type: 'string | string[]', default: 'undefined', description: 'Patterns to exclude from matching.' },
  { name: 'failglob', type: 'boolean', default: 'false', description: 'Throw error if no matches found (takes precedence over nonull).' },
  { name: 'maxLength', type: 'number', default: '65536', description: 'Maximum pattern length. Prevents ReDoS attacks.' },
  { name: 'expandRange', type: 'function', default: 'undefined', description: 'Custom function for expanding ranges in brace patterns.' },
  { name: 'bash', type: 'boolean', default: 'false', description: 'Follow bash matching rules more strictly.' },
  { name: 'contains', type: 'boolean', default: 'false', description: 'Match pattern anywhere in string (not just full match).' },
  { name: 'format', type: 'function', default: 'undefined', description: 'Custom function for formatting strings before matching.' },
  { name: 'flags', type: 'string', default: 'undefined', description: 'Regex flags to use in generated regex.' },
  { name: 'strictBrackets', type: 'boolean', default: 'false', description: 'Throw error if brackets, braces, or parens are imbalanced.' },
  { name: 'literalBrackets', type: 'boolean', default: 'false', description: 'Escape brackets to match literal [ and ].' },
  { name: 'keepQuotes', type: 'boolean', default: 'false', description: 'Retain quotes in the generated regex.' },
  { name: 'unescape', type: 'boolean', default: 'false', description: 'Remove backslashes preceding escaped characters.' },
];

const callbackOptions = [
  { name: 'onMatch', type: 'function', default: 'undefined', description: 'Called when a pattern matches. Receives match result object.' },
  { name: 'onIgnore', type: 'function', default: 'undefined', description: 'Called when a pattern is ignored. Receives match result object.' },
  { name: 'onResult', type: 'function', default: 'undefined', description: 'Called for all results. Receives match result object.' },
];
---

<section class="options" id="options">
  <div class="container">
    <div class="section-header">
      <h2>Options</h2>
      <p>Configuration options for fine-tuning pattern matching</p>
    </div>

    <h3>Core options (minimatch compatible)</h3>
    <div class="table-wrapper">
      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          {coreOptions.map(opt => (
            <tr>
              <td><code>{opt.name}</code></td>
              <td class="type-cell"><code>{opt.type}</code></td>
              <td class="default-cell"><code>{opt.default}</code></td>
              <td class="desc-cell">{opt.description}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>

    <h3>Extended options (v0.3.0+)</h3>
    <p class="new-badge">New in v0.3.0 - picomatch options</p>
    <div class="table-wrapper">
      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          {extendedOptions.map(opt => (
            <tr>
              <td><code>{opt.name}</code></td>
              <td class="type-cell"><code>{opt.type}</code></td>
              <td class="default-cell"><code>{opt.default}</code></td>
              <td class="desc-cell">{opt.description}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>

    <h3>Callback options (v0.3.0+)</h3>
    <div class="table-wrapper">
      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          {callbackOptions.map(opt => (
            <tr>
              <td><code>{opt.name}</code></td>
              <td class="type-cell"><code>{opt.type}</code></td>
              <td class="default-cell"><code>{opt.default}</code></td>
              <td class="desc-cell">{opt.description}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>

    <h3>Examples</h3>
    <div class="examples-grid">
      <div class="example-card">
        <h4>ignore</h4>
        <pre><code>const mm = new Minimatch('**/*.js', {'{'}
  ignore: ['**/*.test.js', '**/node_modules/**']
{'}'});
mm.match('src/app.js');      // true
mm.match('src/app.test.js'); // false</code></pre>
      </div>

      <div class="example-card">
        <h4>failglob</h4>
        <pre><code>// Throw if no matches found
minimatch.match(files, '*.ts', {'{'} failglob: true {'}'});
// Error: No matches found for pattern: *.ts</code></pre>
      </div>

      <div class="example-card">
        <h4>contains</h4>
        <pre><code>// Match anywhere in string
minimatch('foobar', 'bar', {'{'} contains: true {'}'});
// true (matches substring)</code></pre>
      </div>

      <div class="example-card">
        <h4>format</h4>
        <pre><code>// Transform paths before matching
const mm = new Minimatch('src/*.js', {'{'}
  format: (s) => s.replace(/^\.\//, '')
{'}'});
mm.match('./src/app.js'); // true</code></pre>
      </div>

      <div class="example-card">
        <h4>callbacks</h4>
        <pre><code>const mm = new Minimatch('*.js', {'{'}
  onMatch: (r) => console.log('Match:', r.output),
  onResult: (r) => stats[r.isMatch ? 'hits' : 'miss']++
{'}'});</code></pre>
      </div>

      <div class="example-card">
        <h4>literalBrackets</h4>
        <pre><code>// Match literal brackets in filenames
const mm = new Minimatch('[file].js', {'{'}
  literalBrackets: true
{'}'});
mm.match('[file].js'); // true</code></pre>
      </div>
    </div>
  </div>
</section>

<style>
  .options {
    padding: 5rem 0;
  }

  .options h3 {
    margin-top: 2rem;
    margin-bottom: 0.5rem;
    font-size: 1.25rem;
  }

  .new-badge {
    display: inline-block;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    color: white;
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-size: 0.75rem;
    font-weight: 600;
    margin-bottom: 1rem;
  }

  .table-wrapper {
    overflow-x: auto;
    margin-bottom: 2rem;
  }

  table {
    min-width: 900px;
  }

  .type-cell,
  .default-cell {
    white-space: nowrap;
  }

  .type-cell code,
  .default-cell code {
    font-size: 0.75rem;
  }

  .desc-cell {
    font-size: 0.875rem;
    color: var(--gray-600);
  }

  .examples-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 1.5rem;
    margin-top: 1.5rem;
  }

  .example-card {
    background: var(--gray-50);
    border: 1px solid var(--gray-200);
    border-radius: 8px;
    padding: 1.25rem;
  }

  .example-card h4 {
    font-family: var(--font-mono);
    font-size: 0.875rem;
    margin: 0 0 0.75rem 0;
    color: var(--primary);
  }

  .example-card pre {
    margin: 0;
    font-size: 0.75rem;
    line-height: 1.5;
    overflow-x: auto;
  }

  .example-card code {
    font-family: var(--font-mono);
  }
</style>
